<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这里是我的第一个blog</title>
    <url>/2020/07/26/%E8%BF%99%E9%87%8C%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAblog/</url>
    <content><![CDATA[<h1 id="这里是我的第一个blog"><a href="#这里是我的第一个blog" class="headerlink" title="这里是我的第一个blog"></a>这里是我的第一个blog</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"Hello,World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringMVC学习笔记</title>
    <url>/2020/08/01/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://sm.ms/image/jVu5ZylJmCXTekE" target="_blank"><img src="https://i.loli.net/2020/08/02/jVu5ZylJmCXTekE.png" ></a></p>
<a id="more"></a>
<h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1.配置环境"></a>1.配置环境</h3><p>在springMVC中配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.lzy"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springMVC注解识别--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--同步开发使用的视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--prefix是web项目下网页所在文件夹,用/包裹,suffix是web的页面格式,用ModelAndView的时候,setView的string就是该网址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/website/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在web.xml里配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用来初始化变量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化顺序,在加载servlet的时候就初始化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有的访问都映射到DispatcherServlet类中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2.具体使用"></a>2.具体使用</h3><p>第一个简单应用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span><span class="comment">//加注解,可以使其扫描</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/MVCdemo"</span>)<span class="comment">//加注解,做第一个层级,网址变成/MVCdemo/....</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tuserHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@RequestMapping中的名字是浏览器访问方法的地址</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/自定义名字"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"到了methodA"</span>);</span><br><span class="line">        <span class="comment">//return返回值返回的是网页地址,实现了一次转发</span></span><br><span class="line">        <span class="comment">//在web.xml中配置的 &lt;property name="prefix" value="/website/"&gt;&lt;/property&gt;和&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;代表了网站的地址和网站后缀格式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"helloworld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解释义:</p>
<ol>
<li><p><mark>@RequestMapping</mark>:该注解下注释的方法,用get或者post方法都可以获取到前端数据,其()中可以写path,method等属性和值,例如:@RequestMapping(path = “/methodA”,method = RequestMethod.GET),设定了只能取得GET方式发送的参数,如果用POST方式向该方法发送请求则会出现405错误.</p>
</li>
<li><p><mark>@GetMapping</mark>:和上述注解作用相同,直接规定了取得参数的发送方式,发送时形参名要与表单发送的参数名一致即可获得数据.如果传入实体类对象,则对象的成员变量要与表单发送的参数名一致,并会对对象进行set数值赋值.若出现400错误,一般都是参数格式错误,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodB</span><span class="params">(Date birthday)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其中的参数birthday的参数为Date,所以需要做转换,要在参数前增加 @DateTimeFormat(pattern = "yyyy-MM-dd")转换格式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果形参同时是两个对象,而两个对象中持有同名的成员变量,则同时给两个参数的同名的成员变量set赋值</p>
</li>
<li><p>在TomCat服务器下,如果提交的表单的变量,在servlet有中文乱码现象,在GET发送方式下,在其service配置文件中删除useBodyEncodingFromURI和URIEncoding,在POST发送方式下可以添加过滤器,在web.xml下配置如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-接收表单的参数"><a href="#3-接收表单的参数" class="headerlink" title="3.接收表单的参数"></a>3.接收表单的参数<mark></mark></h3><ol>
<li><p><mark>application/x-www-form-urlencoded</mark>:</p>
<p>​        对应的数据格式：key=value&amp;key=value</p>
<p>​        如果是简单类型，加形参，形参名与表单参数名一致。</p>
<p>​        如果是对象类型，加对象形参，表单参数名与对象的属性名一致。</p>
</li>
<li><p><mark>application/json</mark>:(GET请求不能传json数据)</p>
<p>​        需要导入Jackson的三个jar包,其内部原理是通过req.getInputStream()方法得到req的字节流,然后通过JSON.ParseObject(jsonstr,POJO.class)转成可以使用的实参</p>
<p>​        对应的数据格式：{“key”:value,”key”:value}</p>
<p>​        后端需要引入json包。    </p>
<p>​        形参前加@RequestBody注解.</p>
<p>​        PS:不能两个对象中具有相同的成员变量,会出现IO异常</p>
<p>也可以将传来的Json传入map中,例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/all"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">selALL</span><span class="params">(@RequestBody Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">     Tuser tuser = <span class="keyword">new</span> Tuser();</span><br><span class="line">     Tdept tdept = <span class="keyword">new</span> Tdept();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//要导入commons-beanutils和commons-collections的jar包</span></span><br><span class="line">         BeanUtils.populate(tuser,map);</span><br><span class="line">         BeanUtils.populate(tdept,map);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"helloworld"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><mark>@RequestParam与@RequestBody区别</mark>:</p>
<p><mark>@RequestBody</mark>：用来获取前端json格式的数据。只能是对象.</p>
<p><mark>@RequestParam</mark>：用来获取key=value&amp;key=value格式的数据，只用来注解简单数据（Integer，String），可以设置默认值。</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-返回数据给客户端"><a href="#4-返回数据给客户端" class="headerlink" title="4.返回数据给客户端"></a>4.返回数据给客户端</h3><ol>
<li><p>同步请求:把数据放在request域或session域</p>
<p>方法1,通过添加Model形参:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"/getUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">methodD</span><span class="params">(user user,Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>,tuser);<span class="comment">//把数据放在request域</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"helloworld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在jsp页面端通过el表达式$&#123;user&#125;来取值</span></span><br></pre></td></tr></table></figure>

<p>方法2,通过返回ModelAndView视图:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/objuser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">methodC</span><span class="params">(Tuser tuser,Tdept tdept)</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"user"</span>,tuser);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"helloworld"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在jsp页面端通过el表达式$&#123;user&#125;来取值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异步请求:ajax或axios,要把json字符串传给客户端</p>
</li>
</ol>
<ul>
<li><p>可以直接返回对象,在方法名上加<mark>@ResponseBody    </mark>,将返回的数组变成json字符串(前提是有Jackson包),并且只能返回对象</p>
</li>
<li><p>也可以在方法上加<mark>@ResponseEntity</mark>,此时可以返回Colleciton集合,例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/objback"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">methodE</span><span class="params">(String did)</span></span>&#123;</span><br><span class="line">       List&lt;Tuser&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Tuser tuser = <span class="keyword">new</span> Tuser();</span><br><span class="line">       tuser.setDid(did);</span><br><span class="line">       tuser.setUbirthday(<span class="keyword">new</span> Date());</span><br><span class="line">       tuser.setUname(<span class="string">"jack"</span>);</span><br><span class="line">       tuser.setUage(<span class="number">15165</span>);</span><br><span class="line">  </span><br><span class="line">       Tuser tuser1 = <span class="keyword">new</span> Tuser();</span><br><span class="line">       tuser1.setUage(<span class="number">5</span>);</span><br><span class="line">       tuser1.setUname(<span class="string">"shfjsaf"</span>);</span><br><span class="line">       list.add(tuser);</span><br><span class="line">       list.add(tuser1);</span><br><span class="line">       HttpHeaders httpHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">       httpHeaders.add(<span class="string">"Context-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity(list,httpHeaders,HttpStatus.OK);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时return的值,第一个是Collection集合,第二个是HTTPHeaders请求头,这也是这种方法的优势,可以自由设置请求头格式,第三个是返回值的状态200,方便前端在取值前做验证</p>
<h3 id="5-Servlet对象的获取"><a href="#5-Servlet对象的获取" class="headerlink" title="5.Servlet对象的获取"></a>5.Servlet对象的获取</h3><p>方式:在方法的()中加形参<mark>HttpServletRequest,HttpServletResponse,HttpSession</mark>等</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>spring常用注解</title>
    <url>/2020/07/31/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://sm.ms/image/ownc9syh2p17X4Q" target="_blank"><img src="https://i.loli.net/2020/07/31/ownc9syh2p17X4Q.png" ></a></p>
<a id="more"></a>

<h4 id="1-MVC三层结构下-SSM"><a href="#1-MVC三层结构下-SSM" class="headerlink" title="1.MVC三层结构下(SSM):"></a>1.MVC三层结构下(SSM):</h4><p>先配置spring.xml,来扫描注解使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"包名"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><mark>@Repository</mark>:Dao层实现类</p>
</li>
<li><p><mark>@Controller</mark>:controller层</p>
</li>
<li><p><mark>@Service</mark>:service层</p>
</li>
<li><p><mark>@Component</mark>:其他类使用</p>
</li>
<li><p><mark>@Autowired</mark>:自动装配,在成员变量上面添加该注解,<strong>相当于在spring.xml给成员变量进行了property装配</strong>(<!--按照成员变量类型去容器中查找bean对象,通过反射-->)</p>
</li>
<li><p><mark>@Resource</mark>:java内的注解,先根据成员变量名称获取bean<!--获取bean的成员变量名称首字母要小写-->,如果找不到再按照类型去获取bean(当同一个接口有两个实现类的时候使用该注解来代替<mark>@Autowired</mark>以避免异常).</p>
</li>
<li><p><mark>@Qualifier</mark>:作为Resource的补充,用形参名来获取bean</p>
</li>
<li><p>集合注入</p>
<ul>
<li><p>List</p>
<p>方法1</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"自定义"</span> <span class="attr">class</span>=<span class="string">"类路径"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integer"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"double"</span> <span class="attr">value</span>=<span class="string">"156.46"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integer数组"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>值3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key键"</span> <span class="attr">value</span>=<span class="string">"v值"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key键"</span> <span class="attr">value</span>=<span class="string">"v值"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"字符串string"</span> <span class="attr">value</span>=<span class="string">"值"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"类路径"</span> <span class="attr">p:</span>成员变量名=<span class="string">"自定义value"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用的不多,方法叫p-namespace--&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>所有的注解都可以在后面加()小括号并赋值,其赋值含义为该实例的id,通过注解的()属性给bean命名,默认id名称是类名首字母小写剩余补全.</em></p>
</li>
</ul>
<h4 id="2-基于JAVA类的容器配置"><a href="#2-基于JAVA类的容器配置" class="headerlink" title="2.基于JAVA类的容器配置:"></a>2.基于JAVA类的容器配置:</h4><p>  0配置(没有xml文件),在类中使用(不常用,需要看懂).</p>
<ol>
<li><p><mark>@Configuration</mark>:表示该类是配置类</p>
</li>
<li><p><mark>@PropertySource()</mark>:写在<mark>@Configuration</mark>下,括号中写配置文件,注解的()中接受的是数组,表明可以加载多个配置文件,<em>例如@PropertySource(jdbc.properties)</em>,然后用<mark>@Value(“${properties的名称}”)</mark>来给变量赋值,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.name&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String driver;</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><mark>@ComponentScan(“包名”)</mark>:在其他类中加入注解<mark>@Component,@Service,@Controller</mark>等,可以在<mark>getBean()</mark>方法中get扫描过的类的方法或变量(即使用@注解 意味着成为了一个类的一部分),得到加入注解<mark>@Component</mark>的类的方法.</p>
</li>
<li><p><mark>@PostConstruct</mark>:某个类实例化以后立刻调用加该注解的方法,通常用于init()方法.</p>
</li>
<li><p><mark>@PreDestory</mark>:停止程序时销毁该方法</p>
</li>
<li><p><mark>@Bean</mark>:自动实例化该注解下的方法,如果该方法需要传参,则在本类的<mark>@Bean</mark>下寻找需要传参的相同的方法进行传参(类似Xml中的外部Bean引用),注意:<strong>要在有Configuration注解的类下使用</strong>,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDruid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    druidDataSource.setUrl(url);</span><br><span class="line">    druidDataSource.setUsername(username);</span><br><span class="line">    druidDataSource.setDriverClassName(driver);</span><br><span class="line">    druidDataSource.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> druidDataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">createUserService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">    userService.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就把<mark>createDruid()</mark>方法中return的返回值传给了<mark>createUserService(DataSource dataSource)</mark>中所需要的参数.</p>
<p><strong>PS:</strong><mark>@Bean</mark>注解的()中可以有方法,常用的有<strong>initMethod</strong>方法和<strong>destroyMethod</strong>方法,但是要求在该方法下创建的类中有初始化方法和销毁方法,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource ds;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化方法</span></span><br><span class="line">        System.out.println(<span class="string">"userService的init方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//销毁方法</span></span><br><span class="line">        System.out.println(<span class="string">"销毁方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDs</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Spring-Test"><a href="#3-Spring-Test" class="headerlink" title="3.Spring-Test"></a>3.Spring-Test</h4><h5 id="1-spring与junit的整合"><a href="#1-spring与junit的整合" class="headerlink" title="1.spring与junit的整合"></a>1.spring与junit的整合</h5><h6 id="1-1Junit"><a href="#1-1Junit" class="headerlink" title="1.1Junit"></a>1.1Junit</h6></li>
</ol>
<ol>
<li><p><mark>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</mark>:让<mark>@Test</mark>的方法按照方法名的<strong>升序</strong>走</p>
</li>
<li><p><mark>@BeforeClass</mark>:在所有的测试方法执行前先执行一次的初始化方法,<strong>该方法必须是静态的.</strong></p>
</li>
<li><p><mark>@Before</mark>:在执行每个测试方法之前都执行一次该方法,主要用于<strong>让方法都有相同的测试环境</strong></p>
</li>
<li><p><mark>@AfterClass</mark>:在所有的测试方法执行之后执行的销毁方法,<strong>该方法也必须是静态的</strong></p>
</li>
<li><p><mark>@After</mark>:在执行每个测试方法之后都执行一次该方法</p>
</li>
<li><p><mark>Assert</mark>:断言,例如: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Assert.assertEquals(i,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//以及Assert.assertNotEuqals()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该方法,则会得到<u>java.lang.AssertionError</u>异常;</p>
<h6 id="1-2Junit与spring的整合"><a href="#1-2Junit与spring的整合" class="headerlink" title="1.2Junit与spring的整合"></a>1.2Junit与spring的整合</h6><p>利用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@ContextConfiguration("classpath:spring.xml")</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-AOP"><a href="#4-AOP" class="headerlink" title="4.AOP"></a>4.AOP</h4><h5 id="4-1AOP中的几个概念"><a href="#4-1AOP中的几个概念" class="headerlink" title="4.1AOP中的几个概念"></a>4.1AOP中的几个概念</h5><ol>
<li><p>实现方式:动态代理</p>
</li>
<li><p><mark>aspect</mark>:切面,是一个类,类中是非核心的辅助功能代码实现.</p>
</li>
<li><p><mark>advice</mark>:通知,是aspect类中的方法,分为前置通知,返回通知,最终通知,异常通知,环绕通知.</p>
</li>
<li><p><mark>weave</mark>:通过动态代理模式把通知方式插入.</p>
</li>
<li><p><mark>joinpoint</mark>:连接点,是一个方法,其实是核心业务方法</p>
</li>
<li><p><mark>target</mark>:目标对象,连接点方法所在的对象</p>
</li>
<li><p>通过动态代理把切面中的通知方法织入到目标对象连接点方法的周围.</p>
<h5 id="Aop的实现"><a href="#Aop的实现" class="headerlink" title="Aop的实现:"></a>Aop的实现:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&gt;&lt;&#x2F;aop:aspectj-autoproxy&gt;</span><br><span class="line">&#x2F;&#x2F;用以识别aspectj注解</span><br><span class="line">&#x2F;&#x2F;proxy-target-class&#x3D;&quot;false&quot;默认false,如果目标对象有接口,则使用代理,如果没有接口,则使用CGLIB,false就只使用CGLIB</span><br></pre></td></tr></table></figure>

<ol>
<li><p>两种实现方式</p>
<p><strong>基于apsectj注解</strong></p>
<ul>
<li>在元数据配置中，开启aspectj注解识别。</li>
<li>写service层的服务对象(aop中的目标对象)，加服务方法（aop的连接点方法）。</li>
<li>写切面类，写通知方法。</li>
</ul>
</li>
<li><p><mark>@Component</mark>:成为一个bean对象</p>
</li>
<li><p><mark>@Aspect</mark>:成为一个切面bean对象</p>
</li>
<li><p><mark>@Before()</mark>:前置通知方法,()中写的方法是经过<mark>@Pointcut</mark>注解过的方法,表示将前置通知方法植入到切入点表达式的范围的位置</p>
</li>
<li><p><mark>@AfterReturn(pointcut = “” , returning = “”)</mark>:返回通知方法</p>
</li>
<li><p><mark>@AfterThrowing(pointcut = “”,throwing = “”)</mark>:异常通知方法</p>
</li>
<li><p><mark>@After(“”)</mark>:最终通知方法</p>
</li>
<li><p><mark>@Pointcut(“execution(返回值类型  方法名(形参  形参要写到包下,例如java.lang.String))”)</mark>:切入点表达式:定义连接点的集合,要定义一个方法来承载,如果写的是<mark>@Pointcut(“@Annotation(自定义注解包名)”)</mark>,那么带有该自定义注解的方法都是连接点方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//要使用该切面,必须要@ComponentScan中能扫描到的注解的类,例如在类的上方加@Service</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切点表达式,只用作承载,不用写逻辑,第一个*表示任意返回值,方法要到包名下,service.*表示service下的所有类,.*()表示所有方法,(..)中的..表示任意形参</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.lzy.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">servicePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知方法,可以得到连接点的信息(方法,实参),注解()中写的是被切点注解的方法,意味着加入了该切点</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"servicePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object[] args = joinPoint.getArgs();<span class="comment">//得到传入的实参</span></span><br><span class="line">        Object target = joinPoint.getTarget();<span class="comment">//得到目标方法</span></span><br><span class="line">        String name = joinPoint.getSignature().getName();<span class="comment">//得到方法名</span></span><br><span class="line">        <span class="comment">//以上都属于连接点信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//returning表示连接点的返回值,其=的形参要与注解中的第二个形参名相同</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"servicePointCut()"</span>, returning = <span class="string">"bbb"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturnAdvice</span><span class="params">(JoinPoint joinPoint, Object bbb)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterReturning"</span>);</span><br><span class="line">        System.out.println(<span class="string">"bbb:"</span> + bbb);<span class="comment">//打印的是返回值,即return的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知方法,可以得到连接点的信息(方法,实参),还可以得到异常信息,catch里实现</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"servicePointCut()"</span>, throwing = <span class="string">"aaa"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowAdvice</span><span class="params">(JoinPoint joinPoint, Exception aaa)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterThrowing"</span>);</span><br><span class="line">        System.out.println(aaa.getMessage());<span class="comment">//打印的是这个异常的类型,例如ArithmeticException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知方法,finally里实现,这里只能得到连接点信息</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"servicePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果业务中同时需要四个通知,则可以使用环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"servicePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">        Object proceed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置@Before</span></span><br><span class="line">            Object[] args = proceedingJoinPoint.getArgs();<span class="comment">//得到传入的实参</span></span><br><span class="line">            Object target = proceedingJoinPoint.getTarget();<span class="comment">//得到目标方法</span></span><br><span class="line">            String name = proceedingJoinPoint.getSignature().getName();<span class="comment">//得到方法的名字</span></span><br><span class="line">            System.out.println(<span class="string">"前置通知,joinpoint_info:"</span>+Arrays.toString(args)+target+name);</span><br><span class="line">            proceed = proceedingJoinPoint.proceed();<span class="comment">//相当于method.invoke()</span></span><br><span class="line">            <span class="comment">//返回@AfterReturning</span></span><br><span class="line">            System.out.println(<span class="string">"返回通知"</span>+proceed);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//异常@AfterThrowing</span></span><br><span class="line">            System.out.println(<span class="string">"异常通知"</span>+e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最终@After</span></span><br><span class="line">            System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">        IPay iPay = <span class="keyword">new</span> AliPayImpl();<span class="comment">//多态,new的是实现类</span></span><br><span class="line">        IPay proxy = getProxy(iPay);<span class="comment">//这里得到的代理,代理的是接口的实现类</span></span><br><span class="line">        String pay = proxy.pay(<span class="number">5616.156</span>, <span class="string">"aaa"</span>, <span class="string">"bbb"</span>);<span class="comment">//用代理的方法,得到结果集</span></span><br><span class="line">        System.out.println(pay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPay <span class="title">getProxy</span><span class="params">(IPay iP)</span> </span>&#123;</span><br><span class="line">        IPay pay = (IPay) Proxy.newProxyInstance(iP.getClass().getClassLoader(), <span class="keyword">new</span> Class[]&#123;IPay<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                TimeAspect.begin();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = method.invoke(iP, args);<span class="comment">//method是上面的代理使用的方法,即pay方法,传入的iP是IPay接口的AliPayImpl实现类,args是传入的实参,这里是动态获取代理</span></span><br><span class="line">                    System.out.println(<span class="string">"success"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"failed"</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    TimeAspect.end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> pay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.基于XML配置的注解</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这里写切入的方法,把方法放入bean中,相当于@Component--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAspect"</span> <span class="attr">class</span>=<span class="string">"com.lzy.aopTest.LogAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--这里引入aspect方法,用ref引入切入bean的id,相当于@Aspect--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logAspect"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里写切点的aop配置--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"自定义切点id"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.lzy.service.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这里写切入方法的方法名等信息,相当于@Before等注解--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"logger"</span> <span class="attr">pointcut-ref</span>=<span class="string">"自定义切点id"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"自定义切点id所对应类的自定义方法名"</span> <span class="attr">pointcut-ref</span>=<span class="string">"自定义切点id"</span> <span class="attr">returning</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"自定义切点id"</span> <span class="attr">throwing</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"自定义切点id"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="5-反射的概念"><a href="#5-反射的概念" class="headerlink" title="5.反射的概念"></a>5.反射的概念</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反射,在代码运行过程中,来获得类结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.通过类名拿到类的类对象</span></span><br><span class="line">            Class clz = Class.forName(<span class="string">"com.lzy.aop.AliPayImpl"</span>);</span><br><span class="line">            <span class="comment">//可以拿到类的名字</span></span><br><span class="line">            String name = clz.getName();</span><br><span class="line">            <span class="comment">//通过类对象拿到注解(所有注解名)</span></span><br><span class="line">            Annotation annotation = clz.getAnnotation(Repository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Repository r = (Repository) annotation;</span><br><span class="line">                <span class="comment">//得到指定注解名</span></span><br><span class="line">                String repositoryName = r.value();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//得到类中的声明方法,是一个数组</span></span><br><span class="line">            Method[] declaredMethods = clz.getDeclaredMethods();</span><br><span class="line">            <span class="comment">//要取得一个具体的方法,可以通过遍历完成</span></span><br><span class="line">            String methodName = <span class="string">"pay"</span>;</span><br><span class="line">            Method payMethod = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                    payMethod = method;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (payMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//执行拿到的方法,由于反射到的方法没有引用,所以要通过invoke来使用该方法</span></span><br><span class="line">                <span class="comment">//method.invoke(方法所在对象的引用,方法应该传入的实参)</span></span><br><span class="line">                Object o = clz.newInstance();<span class="comment">//通过newInstance()来拿到对象的引用</span></span><br><span class="line">                Object invoke = payMethod.invoke(o, <span class="number">111</span>, <span class="string">"张三"</span>, <span class="string">"李四"</span>);<span class="comment">//返回方法的结果</span></span><br><span class="line">                System.out.println(invoke);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>SSM框架</category>
      </categories>
      <tags>
        <tag>知识分享</tag>
      </tags>
  </entry>
</search>
